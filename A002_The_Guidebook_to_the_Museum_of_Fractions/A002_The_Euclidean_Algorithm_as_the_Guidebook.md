# The Euclidean Algorithm as a guidebook to the museum: rebuilding fractions using the Stern-Brocot tree

The Stern-Brocot tree is like a museum of fractions.  It has exactly one room for every positive fraction between zero and infinity.  For an introduction, see my previous video. 

The Euclidean algorithm is like a guidebook to this museum: the Euclidean algorithm can lead you directly to any fraction of your choice on the Stern-Brocot tree.   This is what I demonstrate in this video.

I recommend using a simple calculator for this exercise. [^calculator]

Let's look for the fraction "3.14",  which is one of the best known approximations of pi.  A number with decimal point is also known as a "decimalized fraction".[^stevinus]  To write "3.14" as one whole number over another,  we write down a single "zero" underneath every digit to the right of the decimal point,  and then turn the decimal point into a "one".    Thus three-point-one-four is equal to three-one-four over one-zero-zero;  three-hundred fourteen over one hundred,  and we can use these names interchangeably. [^welldefined]

To set up the algorithm,  we are going to write the top number to the left, and bottom number to the right.   Then, further to the right, we are going to start in the front room of the Stern-Brocot museum.  The lower boundary fraction of the front room is 0 over 1, and the upper boundary fraction is 1 over 0,  and take the mediant to find the middle fraction is 1 over 1.  So we have five columns of numbers: two natural numbers on the left for the Euclidean algorithm, and three fractions on the right for the Stern-Brocot tree.   The path we walk in the museum will lead us to closer approximations, until we find the exact fraction we are looking for.   Right now, we know the goal, 3.14 is larger than zero,  and less than infinity,  and we'd like to know if 3.14 is smaller than 1, equal to 1, or larger than 1.    

Next, we will calculate 314 minus 100.  The calculator gave us back 214, so that 314 is larger, and 100 is smaller.   Write the smaller number under the larger, and then write 214 under that.  This implies that our goal, 3.14 is larger than the middle fraction 1 over 1, so we want to open the door on the right.  Copy the middle fraction to the left, under the lower boundary fraction.  Notice that we wrote the whole numbers on the left,  and so therefore we copied the middle fraction to the left.  So to finish this row, we just copy the right whole number and the right boundary fraction down to the new row, and use the mediant to calculate the new middle fraction, 2 over 1.  So now we know the goal, 3.14, is between one and infinity, and would like to compare it to two.

So, we repeat these same steps on our new row.  Calculate 214 minus 100,  which is 114.  Write the smaller number, 100, under the larger number, 214, and write 114 under that.  This implies that our goal, 3.14, is larger than the middle fraction 2 over 1, so we want to open the door on the right.  So we are going to copy the middle fraction to the left, under the lower boundary fraction.  Copy down, and use the mediant to calculate the new middle fraction, 3 over 1.   So now we know our goal is between two and infinity, and would like to compare it to three.

We keep repeating these steps on each new row.   Calculate 114 minus 100, which is 14.  Write the smaller number under the the larger, and write 14 under that.  This implies our goal, 3.14, is larger than 3 over 1.  So we are going to copy the middle fraction to the left.  Copy the other two numbers down, and use the mediant to calculate the new middle fraction 4 over 1.   So now we know our goal is between 3 and infinity, and would like to compare it to four.

Next,  14 minus one hundred is negative 86.  The fact the result is negative means 14 is the smaller number, and 100 is the larger number.  Write the smaller number under the larger,  then write 86 under that:  one hundred minus 14 is positive 86, you don't have to recalculate.  This implies our goal, 3.14, is smaller than 4 over 1, and so we want to open the left door.  Notice that because we wrote the whole numbers on the right side of the Euclidean Algorithm, we copy the middle fraction to the right side, under the upper boundary fraction.  Copy left whole number and the left boundary fraction down, and use the mediant to calculate the new middle fraction 7 over 2.  So now we know our goal is between 3 and 4, and we would like to compare it to 7 over 2.

Next,  14 minus 86 is negative 72,  which means we write the smaller number, 14, under the larger, 86,  and subtracting the larger from the smaller, we get positive 72.  This implies our goal, 3.14, is smaller than 7 over 3, and so we want to open the left door.  Since we copied 14 to the right, we are going to copy the middle fraction to the right.  Copy down and find the new mediant, and now we are done with another row.    Now we do the next row, and repeat this same process,  until the two numbers in the Euclidean algorithm equal each other.  (accelerate video at least somewhat + abbreviated commentary)

(Once we reach a few steps past 22/7)   Now, see how 22 over 7 keeps reappearing over and over in the boundary fraction?  That means 22 over 7 is good approximation of 3.14, as every reappearance brings the middle fraction a little bit closer to 22 over 7.  If we wanted to find a fraction that was close to 314 over 100, but with smaller numbers,  22 over 7 would be a particularly good choice. [^pi]

Now, 2 minus 2 is 0,  so that means 2 is equal to 2,  which means have arrived at the room corresponding to 314 over 100.  To check our work, we are going to take the number left over, and multiply the top and bottom of the middle fraction by that number.   This is known as "expanding" fractions.

So 147 * 2 = 314,  and 50 * 2 = 100.  Even though 314 / 100 and 147 / 50 involve different numbers on the top and bottom,  they are exactly equal to each other.  314 / 100 equals 147 / 50.  These two aliases are two different names for the exact same fracton.  [^aliases]

Two is known as the the "greatest common divisor" 314 and 100.  The number left over from the Euclidean algorithm is the greatest common divisor of the numbers we started with.  The greatest common divisor is like an identifier number for the alias of a fraction.

For practice, try finding these fractions on the Stern-Brocot tree using a basic calculator:

However, wouldn't it be nice to have a computer do this work for you?   It's important and useful to learn how to program a computer to solve problems for you.  I highly recommend that you write a computer program to rebuild fractions using the method I demonstrated, and then test your program by using it, playing with it, and experimenting with it.  I cannot recommend this exercise highly enough.

You could use a spreadsheet, such as Microsoft Excel, Google Sheets, or Libreoffice Calc.  You could use a programming language such as Python, JavaScript, CodeWorld, or Dr. Racket.  Or you could use a computer algebra system such as Mathematica, SageMath, Axiom, or Maxima.  Even better, do it all: write this algorithm in a spreadsheet, write it again in a programming language, and again in computer algebra system.  Then maybe write it in a second programming language:  if you chose Python or JavaScript for the first language, maybe choose CodeWorld or Dr. Racket for the second, or vice-versa.    Learning how to use each category of tool can teach you important things that go well beyond the Euclidean algorithm and the Stern-Brocot tree.

You need a computer that you can regularly use to practice these skills;  one inexpensive option is a Raspberry Pi, which includes the LibreOffice Calc spreadsheet, and has everything else I mentioned available, free of charge,  even including an evaluation copy of Mathematica licensed for personal use.  For challenge problems, the website Project Euler has many problems where you are expected to write computer programs to solve a math problem, some of which are difficult even for experts.  For younger viewers especially, I recommend checking out the Art of Problem Solving, which has many excellent math enrichment lessons.


[^calculator]:
    I recommend using a calculator, because there's a lot of arithmetic involved, and any mistake will usually result in an incorrect answer.   Also, I believe this exercise is valuable even for persons who have a concept of adding, subtracting, and comparing multi-digit whole numbers, but don't yet know all the details to perform one or more of these steps.

    Although performing this specific algorithm means doing a lot of arithmetic,  there are more advanced variants of this algorithm involving integer division, multiplication, run-length encoding and an off-by-one error to "upgrade" this algorithm into the divison-based Euclidean algorithm and continued fractions.  If you perform the same calculation using these upgrades, each individual step is more complicated, but there are significantly fewer steps, which on the whole saves a lot of work when finding 3.14's room, and saves a lot of work for most other choices of fraction. 

    After practicing this algorithm a few times with a calculator, I highly recommend implementing this algorithm on a computer.   You could use a spreadsheet program such as Microsoft Excel, Google Sheets, or LibreOffice Calc,  a programming language or two such as Python and CodeWorld, and a computer algebra system such as Mathematica, SageMath, Axiom, or Maxima.  After all, a computer can do the work much more quickly and accurately than you can, even with a basic calculator.  Learning how to make the computer do things for you is an extremely valuable skill, and is often immensely helpful for learning math and science better.

    This approach to learning has been called the white-box/black-box principle by Dr. Doron Zeilberger and Dr. Bruno Buchberger.

[^stevinus]: Simon Stevin, also known as Stevinus, is known for helping to invent decimalized fractions. In many applied settings, decimalized fractions are a more practical choice than continued fractions.  Simon Stevin has a crater on the moon, "Stevinus", named after him. 

[^welldefined]:
    Usually you can interchange names like this,  but you shouldn't always take it for granted that you can, even if they both refer to the exact same concept.  Because as we will see at the end of the video, every fraction has multiple names,  and, as I hope to talk about in greater detail in a future video, it turns out that when you are working with the mediant,  changing which name you use changes the result of the mediant.  For example, consider that 1/1 = 2/2,  but try taking the mediant of those names with 1/2.   In the first case, you get 2/3 â‰ˆ 0.66,  but in the second you get 3/4 = 0.75

    Thus, the mediant is _not_ a well-defined function of fractions, yet it is still useful.  In a very formal sense, the mediant is _not_ a function of fractions at all, although it is perfectly good function of names of fractions, which are pairs of integers.  Although I prefer formality as rule of thumb, I'm willing to make an exception here, because it's really useful to think of the inputs to the mediant as fractions.  Learning that "functions" that are not well-defined can sometimes be very useful indeed is a great lesson to learn early.

    IEEE floating point division is another example of a useful "function" that is not well defined.  IEEE floating point was for a long time was the only arithmetic natively availble in the JavaScript programming language.  So, in this IEEE arithmetic, +0 = -0, but 1 / (+0) = +infinity != -infinity = 1 / (-0),  so even though +0 and -0 are equal, they cannot be substituted for each other in IEEE floating point division.  A part of one justification for these engineering choices is the reason why 1/0 isn't the same thing as infinity in all contexts:  the limit of 1/x as x approaches zero from the right is infinity, whereas the limit of 1/x as x approaches zero from the left is negative infinity.  Thus, why isn't 1/0 equal to negative infinity?
    
    This contrasts quite nicely with the proper way of adding fractions,  where you can freely interchange one name of a fraction with another, with no real consequence.  Sure, a different choice of names for the input might result in a different name for the output, but the resulting name will always refer to the same fraction.  If you reduced the output to least terms, then the choice of name used for the inputs will have no effect.

    Well-definedness is an important in a variety of settings, for example, the key to understanding modular arithmetic reasonably well is to fully own the notion that addition, negation, multiplication, and modular multiplicative inverse are well-defined functions modulo N,  and that exponentiation is a well-defined function from Z_n ^ Z_phi(n) to Z_n,  where phi is Euler's totient function.

    [^aliasing]:  The fact that every fraction has an infinite number of different names, or aliases, is important and will come up again, several times.  The smallest name of a fraction is known as "least terms", and the process of finding least terms is known as "reducing" or "simplifying" fractions.  Amazingly, every fraction appears on the Stern-Brocot tree in least terms.   We can make a list of every alias of a fraction by expanding least terms by 1, by 2, by 3, by 4, and so on.   Thus the greatest common divisor tells you which of the aliases you provided the algorithm.   This is how we can check our work.

    If your only goal is to reduce fractions to least terms, it is less work to use only the Euclidean Algorithm in the left two columns and skip the Stern-Brocot tree in the right three.  This will give you the greatest common divisor, which can then be divided out of the numerator and denominator to find least terms.

    The process of reducing fractions is traditionally one of the major goals of elementary school mathematics.  Often a significant amount of class time will be spent on that topic, and yet students are rarely taught an efficient and effective way to actually compute least terms for arbitrary fractions.  Instead, focus is often placed on prime factorizations and/or trial division.  While the relationship between prime factorizations and least terms is _conceptually important_, is inefficient for anything but the smallest examples.

    The idea that prime factorization takes so much effort, even for a computer, is a key idea behind RSA public-key cryptography.  Also, the extended Euclidean Algorithm (or rather constant-time variants thereof) is actually a critically important part of an implementation of not only the RSA algorithm, but also more modern elliptic curve algorithms as well.  In this latter case, the extended Euclidean algorithm is modified to operate on esoteric, finite (but very large) arithmetics like secp256k1, ed25519, and Curve448.  See for example [A Formal Proof of safegcd Bounds](https://medium.com/blockstream/a-formal-proof-of-safegcd-bounds-695e1735a348).

[^pi]:
    Like 3.14,  22/7 is also a well-known approximation of pi.  It's actually slightly closer to pi than 3.14, despite the fact that it has a smaller denominator.

    Pi is irrational, so therefore it cannot be found in any room on the Stern-Brocot tree.   However, it's still useful to look for pi on the Stern-Brocot tree, because doing will lead you to all of the best rational approximations of pi.  Because the Stern-Brocot tree is a binary search tree of rationals and pi is irrational, there is a unique, infinitely long trail towards pi.  This trail approaches pi to arbitrary precision.  22/7 is an example of a _convergent_ of pi, because it appears two or more times in the boundary fractions you see along this path.   Because 22/7 is a convergent, it's a best rational approximation:  it's guaranteed to be either be closer to pi, or have a smaller denominator, than any other rational approximation of pi, including other convergents.

    Convergents are associated with changes in direction along this trail.   The first four convergents of pi are 3, 22/7, 333/106, and 355/113.   The latter three can all be found in a single room of the Stern-Brocot tree:  the boundary fractions of 355/113 are 333/106 and 22/7.

    If you look for the room that corresponds to a decimal approximation of pi, such as 3.14, 3.15, 3.141, 3.142, 3.1415, 3.1416, etc,  the trail to that room will start off following the trail to pi,  but most of the time, that room won't be on the trail to pi, and thus you should expect that going all the way to that room will take you off the trail.  However, 3.14 is special, because its room is on the trail to pi.  It is not a convergent of pi, because 3.14 only ever appears once (as 147 / 50) in the boundary fractions along the trail,  but the fact it appears at all means that 3.14 is a "semi-convergent" of pi.  Every convergent is a semi-convergent, so 22/7 is a semi-convergent too.

    It turns out that any semi-convergent is a better rational approximation than anything that is not a semi-convergent.  However, semi-convergents can either be "shadowed" or "optimal".  For example, 3.14 is a shadowed semi-convergent of pi.  It is shadowed by 22/7, which is closer to pi and has a smaller denominator.  Optimal semi-convergents are best rational approximations:  this includes all of the full convergents,  and some of the proper semi-convergents.  However, full convergents provide a much larger increase in precision than optimal proper semi-convergents, and thus full convergents are superlative optimal semi-convergents.

    Not all convergents are made equal either:  for example 355/113 is an extra-superlative convergent of pi, even compared to most other convergents, because once we find the room associated with 355/113, we have to go left once and then right 291 times to find the next full convergent 103993/33102,  or left once and right 145 times in order to find the next optimal semi-convergent  52163/16604, which is just barely closer to pi than 355/113 despite involving a much larger numerator and denominator.  Each of these steps brings us closer to 355/113.

    These techniques of rational approximation, once practiced, aren't particularly difficult.  However, they seem to be deeply underappreciated at the time I made this video, even among math professors and math students.  I have some fairly concrete evidence of this: as of this video, Project Euler problem #192 has only 1596 claimed solutions in the 14 years it has been posted,  when the mathematics seems important and basic enough that it probably should have ten thousand or more claimed solutions.  For advanced viewers, I certainly do recommend trying to write a computer program to solve Project Euler #192 and submitting your solution to the site.   (But please don't juke the stats:  only submit a solution you've worked on, and only submit a solution under a single account.)